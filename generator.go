package main

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"reflect"
	"strings"
	"text/template"
)

type Field struct {
	Name      string
	Type      string
	FlagName  string
	ShortFlag string
	Usage     string
	Default   string
}

type GeneratorData struct {
	Package    string
	StructName string
	Fields     []Field
}

func generateFlags(inputFile, outputFile, structName, pkgName string) error {
	// Parse the input file
	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, inputFile, nil, parser.ParseComments)
	if err != nil {
		return fmt.Errorf("failed to parse input file: %w", err)
	}

	// Find the struct
	var fields []Field
	ast.Inspect(node, func(n ast.Node) bool {
		typeSpec, ok := n.(*ast.TypeSpec)
		if !ok || typeSpec.Name.Name != structName {
			return true
		}

		structType, ok := typeSpec.Type.(*ast.StructType)
		if !ok {
			return true
		}

		for _, field := range structType.Fields.List {
			if len(field.Names) == 0 {
				continue
			}

			fieldName := field.Names[0].Name
			fieldType := getTypeName(field.Type)

			// Parse struct tag
			var flagName, shortFlag, usage, defaultVal string
			if field.Tag != nil {
				tag := field.Tag.Value
				tag = strings.Trim(tag, "`")
				
				// Use reflect.StructTag for proper tag parsing
				structTag := reflect.StructTag(tag)
				
				// Parse flag tag
				if flagTag := structTag.Get("flag"); flagTag != "" {
					flagName = flagTag
				}
				
				// Parse short tag
				if shortTag := structTag.Get("short"); shortTag != "" {
					shortFlag = shortTag
				}
				
				// Parse usage tag
				if usageTag := structTag.Get("usage"); usageTag != "" {
					usage = usageTag
				}
				
				// Parse default tag
				if defaultTag := structTag.Get("default"); defaultTag != "" {
					defaultVal = defaultTag
				}
			}

			// Default flag name is lowercase field name
			if flagName == "" {
				flagName = strings.ToLower(fieldName)
			}

			fields = append(fields, Field{
				Name:      fieldName,
				Type:      fieldType,
				FlagName:  flagName,
				ShortFlag: shortFlag,
				Usage:     usage,
				Default:   defaultVal,
			})
		}

		return false
	})

	if len(fields) == 0 {
		return fmt.Errorf("struct %s not found or has no fields", structName)
	}

	// Generate the output
	data := GeneratorData{
		Package:    pkgName,
		StructName: structName,
		Fields:     fields,
	}

	tmpl := template.Must(template.New("flags").Parse(flagsTemplate))

	f, err := os.Create(outputFile)
	if err != nil {
		return fmt.Errorf("failed to create output file: %w", err)
	}
	defer f.Close()

	if err := tmpl.Execute(f, data); err != nil {
		return fmt.Errorf("failed to generate code: %w", err)
	}

	return nil
}

func getTypeName(expr ast.Expr) string {
	switch t := expr.(type) {
	case *ast.Ident:
		return t.Name
	case *ast.StarExpr:
		return "*" + getTypeName(t.X)
	case *ast.ArrayType:
		return "[]" + getTypeName(t.Elt)
	case *ast.SelectorExpr:
		return getTypeName(t.X) + "." + t.Sel.Name
	default:
		return "unknown"
	}
}



const flagsTemplate = `// Code generated by gen-cobra-flags. DO NOT EDIT.
package {{.Package}}

import (
	"github.com/spf13/cobra"
)

// Add{{.StructName}}Flags adds flags for {{.StructName}} to the cobra command
func Add{{.StructName}}Flags(cmd *cobra.Command, config *{{.StructName}}) {
{{- range .Fields}}
	{{- if eq .Type "string"}}
	cmd.Flags().StringVarP(&config.{{.Name}}, "{{.FlagName}}", "{{.ShortFlag}}", "{{.Default}}", "{{.Usage}}")
	{{- else if eq .Type "int"}}
	cmd.Flags().IntVarP(&config.{{.Name}}, "{{.FlagName}}", "{{.ShortFlag}}", {{if .Default}}{{.Default}}{{else}}0{{end}}, "{{.Usage}}")
	{{- else if eq .Type "bool"}}
	cmd.Flags().BoolVarP(&config.{{.Name}}, "{{.FlagName}}", "{{.ShortFlag}}", {{if .Default}}{{.Default}}{{else}}false{{end}}, "{{.Usage}}")
	{{- else if eq .Type "[]string"}}
	cmd.Flags().StringSliceVarP(&config.{{.Name}}, "{{.FlagName}}", "{{.ShortFlag}}", nil, "{{.Usage}}")
	{{- else}}
	// Unsupported type {{.Type}} for field {{.Name}}
	{{- end}}
{{- end}}
}
`
